package repositories

import (
	"context"
	"errors"

	"{{.ServiceName}}/internal/models"

	"github.com/anasamu/go-micro-libs"
	"gorm.io/gorm"
)

// Repository handles data access operations
type Repository struct {
	dbManager *microservices.DatabaseManager
	db        *gorm.DB
}

// NewRepository creates a new repository instance
func NewRepository(dbManager *microservices.DatabaseManager) *Repository {
	return &Repository{
		dbManager: dbManager,
	}
}

// Connect establishes database connection
func (r *Repository) Connect(ctx context.Context) error {
	if r.dbManager == nil {
		return errors.New("database manager is not initialized")
	}

	// Get database provider
	provider := r.dbManager.GetProvider("postgresql")
	if provider == nil {
		return errors.New("postgresql provider not found")
	}

	// Get GORM DB instance
	db, ok := provider.(*gorm.DB)
	if !ok {
		return errors.New("failed to get GORM DB instance")
	}

	r.db = db
	return nil
}

// UserRepository handles user data operations
type UserRepository struct {
	*Repository
}

// NewUserRepository creates a new user repository
func NewUserRepository(repo *Repository) *UserRepository {
	return &UserRepository{Repository: repo}
}

// CreateUser creates a new user
func (ur *UserRepository) CreateUser(ctx context.Context, user *models.User) error {
	if ur.db == nil {
		return errors.New("database connection not established")
	}

	result := ur.db.WithContext(ctx).Create(user)
	if result.Error != nil {
		return result.Error
	}

	return nil
}

// GetUser retrieves a user by ID
func (ur *UserRepository) GetUser(ctx context.Context, id uint) (*models.User, error) {
	if ur.db == nil {
		return nil, errors.New("database connection not established")
	}

	var user models.User
	result := ur.db.WithContext(ctx).First(&user, id)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, errors.New("user not found")
		}
		return nil, result.Error
	}

	return &user, nil
}

// GetUserByUsername retrieves a user by username
func (ur *UserRepository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) {
	if ur.db == nil {
		return nil, errors.New("database connection not established")
	}

	var user models.User
	result := ur.db.WithContext(ctx).Where("username = ?", username).First(&user)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, errors.New("user not found")
		}
		return nil, result.Error
	}

	return &user, nil
}

// GetUserByEmail retrieves a user by email
func (ur *UserRepository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
	if ur.db == nil {
		return nil, errors.New("database connection not established")
	}

	var user models.User
	result := ur.db.WithContext(ctx).Where("email = ?", email).First(&user)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, errors.New("user not found")
		}
		return nil, result.Error
	}

	return &user, nil
}

// GetUsers retrieves all users with pagination
func (ur *UserRepository) GetUsers(ctx context.Context, page, pageSize int) ([]*models.User, int64, error) {
	if ur.db == nil {
		return nil, 0, errors.New("database connection not established")
	}

	var users []*models.User
	var total int64

	// Count total records
	if err := ur.db.WithContext(ctx).Model(&models.User{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// Get paginated results
	offset := (page - 1) * pageSize
	result := ur.db.WithContext(ctx).
		Offset(offset).
		Limit(pageSize).
		Find(&users)

	if result.Error != nil {
		return nil, 0, result.Error
	}

	return users, total, nil
}

// UpdateUser updates an existing user
func (ur *UserRepository) UpdateUser(ctx context.Context, user *models.User) error {
	if ur.db == nil {
		return errors.New("database connection not established")
	}

	result := ur.db.WithContext(ctx).Save(user)
	if result.Error != nil {
		return result.Error
	}

	return nil
}

// DeleteUser soft deletes a user
func (ur *UserRepository) DeleteUser(ctx context.Context, id uint) error {
	if ur.db == nil {
		return errors.New("database connection not established")
	}

	result := ur.db.WithContext(ctx).Delete(&models.User{}, id)
	if result.Error != nil {
		return result.Error
	}

	if result.RowsAffected == 0 {
		return errors.New("user not found")
	}

	return nil
}

// UserExists checks if a user exists by username or email
func (ur *UserRepository) UserExists(ctx context.Context, username, email string) (bool, error) {
	if ur.db == nil {
		return false, errors.New("database connection not established")
	}

	var count int64
	result := ur.db.WithContext(ctx).
		Model(&models.User{}).
		Where("username = ? OR email = ?", username, email).
		Count(&count)

	if result.Error != nil {
		return false, result.Error
	}

	return count > 0, nil
}

// ActivateUser activates a user
func (ur *UserRepository) ActivateUser(ctx context.Context, id uint) error {
	if ur.db == nil {
		return errors.New("database connection not established")
	}

	result := ur.db.WithContext(ctx).
		Model(&models.User{}).
		Where("id = ?", id).
		Update("is_active", true)

	if result.Error != nil {
		return result.Error
	}

	if result.RowsAffected == 0 {
		return errors.New("user not found")
	}

	return nil
}

// DeactivateUser deactivates a user
func (ur *UserRepository) DeactivateUser(ctx context.Context, id uint) error {
	if ur.db == nil {
		return errors.New("database connection not established")
	}

	result := ur.db.WithContext(ctx).
		Model(&models.User{}).
		Where("id = ?", id).
		Update("is_active", false)

	if result.Error != nil {
		return result.Error
	}

	if result.RowsAffected == 0 {
		return errors.New("user not found")
	}

	return nil
}

// SearchUsers searches users by query
func (ur *UserRepository) SearchUsers(ctx context.Context, query string, page, pageSize int) ([]*models.User, int64, error) {
	if ur.db == nil {
		return nil, 0, errors.New("database connection not established")
	}

	var users []*models.User
	var total int64

	searchQuery := "%" + query + "%"

	// Count total records
	if err := ur.db.WithContext(ctx).
		Model(&models.User{}).
		Where("username ILIKE ? OR email ILIKE ? OR first_name ILIKE ? OR last_name ILIKE ?",
			searchQuery, searchQuery, searchQuery, searchQuery).
		Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// Get paginated results
	offset := (page - 1) * pageSize
	result := ur.db.WithContext(ctx).
		Where("username ILIKE ? OR email ILIKE ? OR first_name ILIKE ? OR last_name ILIKE ?",
			searchQuery, searchQuery, searchQuery, searchQuery).
		Offset(offset).
		Limit(pageSize).
		Find(&users)

	if result.Error != nil {
		return nil, 0, result.Error
	}

	return users, total, nil
}

// GetActiveUsers retrieves all active users
func (ur *UserRepository) GetActiveUsers(ctx context.Context) ([]*models.User, error) {
	if ur.db == nil {
		return nil, errors.New("database connection not established")
	}

	var users []*models.User
	result := ur.db.WithContext(ctx).
		Where("is_active = ?", true).
		Find(&users)

	if result.Error != nil {
		return nil, result.Error
	}

	return users, nil
}

// GetInactiveUsers retrieves all inactive users
func (ur *UserRepository) GetInactiveUsers(ctx context.Context) ([]*models.User, error) {
	if ur.db == nil {
		return nil, errors.New("database connection not established")
	}

	var users []*models.User
	result := ur.db.WithContext(ctx).
		Where("is_active = ?", false).
		Find(&users)

	if result.Error != nil {
		return nil, result.Error
	}

	return users, nil
}

// GetUserCount retrieves the total number of users
func (ur *UserRepository) GetUserCount(ctx context.Context) (int64, error) {
	if ur.db == nil {
		return 0, errors.New("database connection not established")
	}

	var count int64
	result := ur.db.WithContext(ctx).Model(&models.User{}).Count(&count)
	if result.Error != nil {
		return 0, result.Error
	}

	return count, nil
}

// GetActiveUserCount retrieves the number of active users
func (ur *UserRepository) GetActiveUserCount(ctx context.Context) (int64, error) {
	if ur.db == nil {
		return 0, errors.New("database connection not established")
	}

	var count int64
	result := ur.db.WithContext(ctx).
		Model(&models.User{}).
		Where("is_active = ?", true).
		Count(&count)

	if result.Error != nil {
		return 0, result.Error
	}

	return count, nil
}

// GetInactiveUserCount retrieves the number of inactive users
func (ur *UserRepository) GetInactiveUserCount(ctx context.Context) (int64, error) {
	if ur.db == nil {
		return 0, errors.New("database connection not established")
	}

	var count int64
	result := ur.db.WithContext(ctx).
		Model(&models.User{}).
		Where("is_active = ?", false).
		Count(&count)

	if result.Error != nil {
		return 0, result.Error
	}

	return count, nil
}
