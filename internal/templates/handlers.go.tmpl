package handlers

import (
	"net/http"

	"{{.ServiceName}}/internal/services"
	"{{.ServiceName}}/pkg/types"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
	"github.com/anasamu/go-micro-libs"
)

// Handler handles HTTP requests
type Handler struct {
	service      *services.Service
	authManager  *microservices.AuthManager
	apiManager   *microservices.APIManager
	emailManager *microservices.EmailManager
	logger       *logrus.Logger
}

// NewHandler creates a new handler instance
func NewHandler(service *services.Service, authManager *microservices.AuthManager, apiManager *microservices.APIManager, emailManager *microservices.EmailManager) *Handler {
	return &Handler{
		service:      service,
		authManager:  authManager,
		apiManager:   apiManager,
		emailManager: emailManager,
		logger:       logrus.New(),
	}
}

// RegisterRoutes registers all HTTP routes
func (h *Handler) RegisterRoutes(router *gin.Engine) {
	// Health check endpoint
	router.GET("/health", h.HealthCheck)

	// API v1 routes
	v1 := router.Group("/api/v1")
	{
		// Public routes
		v1.GET("/ping", h.Ping)

		{{- if .WithAuth}}
		// Auth routes
		auth := v1.Group("/auth")
		{
			auth.POST("/login", h.Login)
			auth.POST("/register", h.Register)
			auth.POST("/refresh", h.RefreshToken)
			auth.POST("/logout", h.Logout)
		}

		// Protected routes
		protected := v1.Group("/")
		protected.Use(h.AuthMiddleware())
		{
			// User routes
			users := protected.Group("/users")
			{
				users.GET("/", h.GetUsers)
				users.GET("/:id", h.GetUser)
				users.POST("/", h.CreateUser)
				users.PUT("/:id", h.UpdateUser)
				users.DELETE("/:id", h.DeleteUser)
			}
		}
		{{- else}}
		// User routes (without auth)
		users := v1.Group("/users")
		{
			users.GET("/", h.GetUsers)
			users.GET("/:id", h.GetUser)
			users.POST("/", h.CreateUser)
			users.PUT("/:id", h.UpdateUser)
			users.DELETE("/:id", h.DeleteUser)
		}
		{{- end}}

		{{- if .WithAPI}}
		// API thirdparty routes
		api := v1.Group("/api")
		{
			api.POST("/http", h.SendHTTPRequest)
			api.POST("/graphql", h.SendGraphQLRequest)
			api.POST("/grpc", h.SendgRPCRequest)
			api.POST("/websocket", h.ConnectWebSocket)
		}
		{{- end}}

		{{- if .WithEmail}}
		// Email routes
		email := v1.Group("/email")
		{
			email.POST("/send", h.SendEmail)
			email.POST("/send-template", h.SendEmailWithTemplate)
			email.POST("/send-batch", h.SendBatchEmails)
			email.POST("/templates", h.CreateEmailTemplate)
			email.GET("/templates/:id", h.GetEmailTemplate)
		}
		{{- end}}
	}
}

// HealthCheck handles health check requests
func (h *Handler) HealthCheck(c *gin.Context) {
	health := map[string]interface{}{
		"status":    "healthy",
		"service":   "{{.ServiceName}}",
		"version":   "1.0.0",
		"timestamp": "2024-01-01T00:00:00Z",
	}

	c.JSON(http.StatusOK, health)
}

// Ping handles ping requests
func (h *Handler) Ping(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "pong",
		"service": "{{.ServiceName}}",
	})
}

{{- if .WithAuth}}

// Login handles user login
func (h *Handler) Login(c *gin.Context) {
	var req types.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid login request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	// Use existing auth library
	authReq := &auth.AuthRequest{
		Username: req.Username,
		Password: req.Password,
	}

	authResp, err := h.authManager.Authenticate(c.Request.Context(), "jwt", authReq)
	if err != nil {
		h.logger.Error("Authentication failed:", err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"access_token":  authResp.AccessToken,
		"refresh_token": authResp.RefreshToken,
		"expires_in":    authResp.ExpiresIn,
	})
}

// Register handles user registration
func (h *Handler) Register(c *gin.Context) {
	var req types.RegisterRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid registration request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	user, err := h.service.CreateUser(c.Request.Context(), &req)
	if err != nil {
		h.logger.Error("Failed to create user:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	c.JSON(http.StatusCreated, user)
}

// RefreshToken handles token refresh
func (h *Handler) RefreshToken(c *gin.Context) {
	var req types.RefreshTokenRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid refresh request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	// Use existing auth library
	refreshReq := &auth.RefreshTokenRequest{
		RefreshToken: req.RefreshToken,
	}

	authResp, err := h.authManager.RefreshToken(c.Request.Context(), "jwt", refreshReq)
	if err != nil {
		h.logger.Error("Token refresh failed:", err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid refresh token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"access_token":  authResp.AccessToken,
		"refresh_token": authResp.RefreshToken,
		"expires_in":    authResp.ExpiresIn,
	})
}

// Logout handles user logout
func (h *Handler) Logout(c *gin.Context) {
	var req types.LogoutRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid logout request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	// Use existing auth library
	logoutReq := &auth.RevokeTokenRequest{
		Token: req.AccessToken,
	}

	err := h.authManager.RevokeToken(c.Request.Context(), "jwt", logoutReq)
	if err != nil {
		h.logger.Error("Logout failed:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Logout failed"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})
}

// AuthMiddleware provides authentication middleware
func (h *Handler) AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.GetHeader("Authorization")
		if token == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authorization header"})
			c.Abort()
			return
		}

		// Remove "Bearer " prefix
		if len(token) > 7 && token[:7] == "Bearer " {
			token = token[7:]
		}

		// Use existing auth library
		validateReq := &auth.TokenValidationRequest{
			Token: token,
		}

		validateResp, err := h.authManager.ValidateToken(c.Request.Context(), "jwt", validateReq)
		if err != nil {
			h.logger.Error("Token validation failed:", err)
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		// Set user info in context
		c.Set("user_id", validateResp.UserID)
		c.Set("user_roles", validateResp.Roles)
		c.Next()
	}
}

{{- end}}

// GetUsers handles getting all users
func (h *Handler) GetUsers(c *gin.Context) {
	users, err := h.service.GetUsers(c.Request.Context())
	if err != nil {
		h.logger.Error("Failed to get users:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get users"})
		return
	}

	c.JSON(http.StatusOK, users)
}

// GetUser handles getting a specific user
func (h *Handler) GetUser(c *gin.Context) {
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "User ID is required"})
		return
	}

	user, err := h.service.GetUser(c.Request.Context(), userID)
	if err != nil {
		h.logger.Error("Failed to get user:", err)
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// CreateUser handles creating a new user
func (h *Handler) CreateUser(c *gin.Context) {
	var req types.CreateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid create user request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	user, err := h.service.CreateUser(c.Request.Context(), &req)
	if err != nil {
		h.logger.Error("Failed to create user:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	c.JSON(http.StatusCreated, user)
}

// UpdateUser handles updating a user
func (h *Handler) UpdateUser(c *gin.Context) {
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "User ID is required"})
		return
	}

	var req types.UpdateUserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid update user request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	user, err := h.service.UpdateUser(c.Request.Context(), userID, &req)
	if err != nil {
		h.logger.Error("Failed to update user:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// DeleteUser handles deleting a user
func (h *Handler) DeleteUser(c *gin.Context) {
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "User ID is required"})
		return
	}

	err := h.service.DeleteUser(c.Request.Context(), userID)
	if err != nil {
		h.logger.Error("Failed to delete user:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user"})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}

{{- if .WithAPI}}

// SendHTTPRequest handles HTTP API requests
func (h *Handler) SendHTTPRequest(c *gin.Context) {
	var req types.HTTPRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid HTTP request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	apiService := services.NewAPIService(h.service)
	response, err := apiService.SendHTTPRequest(c.Request.Context(), req.Method, req.URL, req.Headers, req.Body)
	if err != nil {
		h.logger.Error("Failed to send HTTP request:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send HTTP request"})
		return
	}

	c.JSON(http.StatusOK, response)
}

// SendGraphQLRequest handles GraphQL API requests
func (h *Handler) SendGraphQLRequest(c *gin.Context) {
	var req types.GraphQLRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid GraphQL request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	apiService := services.NewAPIService(h.service)
	response, err := apiService.SendGraphQLRequest(c.Request.Context(), req.Query, req.Variables)
	if err != nil {
		h.logger.Error("Failed to send GraphQL request:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send GraphQL request"})
		return
	}

	c.JSON(http.StatusOK, response)
}

// SendgRPCRequest handles gRPC API requests
func (h *Handler) SendgRPCRequest(c *gin.Context) {
	var req types.GRPCRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid gRPC request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	apiService := services.NewAPIService(h.service)
	response, err := apiService.SendgRPCRequest(c.Request.Context(), req.Service, req.Method, req.Data)
	if err != nil {
		h.logger.Error("Failed to send gRPC request:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send gRPC request"})
		return
	}

	c.JSON(http.StatusOK, response)
}

// ConnectWebSocket handles WebSocket connections
func (h *Handler) ConnectWebSocket(c *gin.Context) {
	var req types.WebSocketRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid WebSocket request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	apiService := services.NewAPIService(h.service)
	response, err := apiService.ConnectWebSocket(c.Request.Context(), req.URL, req.Headers)
	if err != nil {
		h.logger.Error("Failed to connect WebSocket:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to connect WebSocket"})
		return
	}

	c.JSON(http.StatusOK, response)
}

{{- end}}

{{- if .WithEmail}}

// SendEmail handles sending emails
func (h *Handler) SendEmail(c *gin.Context) {
	var req types.SendEmailRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid send email request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	emailService := services.NewEmailService(h.service)
	response, err := emailService.SendEmail(c.Request.Context(), req.To, req.Subject, req.Body, req.IsHTML)
	if err != nil {
		h.logger.Error("Failed to send email:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send email"})
		return
	}

	c.JSON(http.StatusOK, response)
}

// SendEmailWithTemplate handles sending emails with templates
func (h *Handler) SendEmailWithTemplate(c *gin.Context) {
	var req types.SendEmailTemplateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid send email template request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	emailService := services.NewEmailService(h.service)
	response, err := emailService.SendEmailWithTemplate(c.Request.Context(), req.To, req.TemplateID, req.Data)
	if err != nil {
		h.logger.Error("Failed to send email with template:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send email with template"})
		return
	}

	c.JSON(http.StatusOK, response)
}

// SendBatchEmails handles sending batch emails
func (h *Handler) SendBatchEmails(c *gin.Context) {
	var req types.SendBatchEmailRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid send batch email request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	emailService := services.NewEmailService(h.service)
	response, err := emailService.SendBatchEmails(c.Request.Context(), req.Emails)
	if err != nil {
		h.logger.Error("Failed to send batch emails:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send batch emails"})
		return
	}

	c.JSON(http.StatusOK, response)
}

// CreateEmailTemplate handles creating email templates
func (h *Handler) CreateEmailTemplate(c *gin.Context) {
	var req types.CreateEmailTemplateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("Invalid create email template request:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	emailService := services.NewEmailService(h.service)
	err := emailService.CreateEmailTemplate(c.Request.Context(), req.TemplateID, req.Name, req.Subject, req.Body)
	if err != nil {
		h.logger.Error("Failed to create email template:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create email template"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Email template created successfully"})
}

// GetEmailTemplate handles retrieving email templates
func (h *Handler) GetEmailTemplate(c *gin.Context) {
	templateID := c.Param("id")
	if templateID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Template ID is required"})
		return
	}

	emailService := services.NewEmailService(h.service)
	template, err := emailService.GetEmailTemplate(c.Request.Context(), templateID)
	if err != nil {
		h.logger.Error("Failed to get email template:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get email template"})
		return
	}

	c.JSON(http.StatusOK, template)
}

{{- end}}
