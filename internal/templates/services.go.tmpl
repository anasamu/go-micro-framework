package services

import (
	"context"
	"errors"

	"{{.ServiceName}}/internal/models"
	"{{.ServiceName}}/internal/repositories"

	"github.com/anasamu/go-micro-libs"
	"golang.org/x/crypto/bcrypt"
)

// Service handles business logic operations
type Service struct {
	userRepo      *repositories.UserRepository
	authManager   *microservices.AuthManager
	apiManager    *microservices.APIManager
	emailManager  *microservices.EmailManager
}

// NewService creates a new service instance
func NewService(repo *repositories.Repository, authManager *microservices.AuthManager, apiManager *microservices.APIManager, emailManager *microservices.EmailManager) *Service {
	userRepo := repositories.NewUserRepository(repo)
	
	return &Service{
		userRepo:     userRepo,
		authManager:  authManager,
		apiManager:   apiManager,
		emailManager: emailManager,
	}
}

// UserService handles user-related business logic
type UserService struct {
	*Service
}

// NewUserService creates a new user service
func NewUserService(service *Service) *UserService {
	return &UserService{Service: service}
}

// CreateUser creates a new user
func (us *UserService) CreateUser(ctx context.Context, req *models.CreateUserRequest) (*models.UserResponse, error) {
	// Check if user already exists
	exists, err := us.userRepo.UserExists(ctx, req.Username, req.Email)
	if err != nil {
		return nil, err
	}
	if exists {
		return nil, errors.New("user already exists")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	// Create user model
	user := &models.User{
		Username:  req.Username,
		Email:     req.Email,
		Password:  string(hashedPassword),
		FirstName: req.FirstName,
		LastName:  req.LastName,
		IsActive:  true,
	}

	// Save user to database
	if err := us.userRepo.CreateUser(ctx, user); err != nil {
		return nil, err
	}

	return user.ToResponse(), nil
}

// GetUser retrieves a user by ID
func (us *UserService) GetUser(ctx context.Context, id uint) (*models.UserResponse, error) {
	user, err := us.userRepo.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}

	return user.ToResponse(), nil
}

// GetUserByUsername retrieves a user by username
func (us *UserService) GetUserByUsername(ctx context.Context, username string) (*models.UserResponse, error) {
	user, err := us.userRepo.GetUserByUsername(ctx, username)
	if err != nil {
		return nil, err
	}

	return user.ToResponse(), nil
}

// GetUserByEmail retrieves a user by email
func (us *UserService) GetUserByEmail(ctx context.Context, email string) (*models.UserResponse, error) {
	user, err := us.userRepo.GetUserByEmail(ctx, email)
	if err != nil {
		return nil, err
	}

	return user.ToResponse(), nil
}

// GetUsers retrieves all users with pagination
func (us *UserService) GetUsers(ctx context.Context, page, pageSize int) (*models.PaginationResponse, error) {
	if page <= 0 {
		page = 1
	}
	if pageSize <= 0 {
		pageSize = 10
	}

	users, total, err := us.userRepo.GetUsers(ctx, page, pageSize)
	if err != nil {
		return nil, err
	}

	// Convert to response format
	var userResponses []*models.UserResponse
	for _, user := range users {
		userResponses = append(userResponses, user.ToResponse())
	}

	totalPages := int(total) / pageSize
	if int(total)%pageSize > 0 {
		totalPages++
	}

	return &models.PaginationResponse{
		Page:       page,
		PageSize:   pageSize,
		Total:      total,
		TotalPages: totalPages,
		Data:       userResponses,
	}, nil
}

// UpdateUser updates an existing user
func (us *UserService) UpdateUser(ctx context.Context, id uint, req *models.UpdateUserRequest) (*models.UserResponse, error) {
	// Get existing user
	user, err := us.userRepo.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}

	// Update fields if provided
	if req.Username != nil {
		user.Username = *req.Username
	}
	if req.Email != nil {
		user.Email = *req.Email
	}
	if req.FirstName != nil {
		user.FirstName = *req.FirstName
	}
	if req.LastName != nil {
		user.LastName = *req.LastName
	}
	if req.IsActive != nil {
		user.IsActive = *req.IsActive
	}

	// Save updated user
	if err := us.userRepo.UpdateUser(ctx, user); err != nil {
		return nil, err
	}

	return user.ToResponse(), nil
}

// DeleteUser soft deletes a user
func (us *UserService) DeleteUser(ctx context.Context, id uint) error {
	return us.userRepo.DeleteUser(ctx, id)
}

// ActivateUser activates a user
func (us *UserService) ActivateUser(ctx context.Context, id uint) error {
	return us.userRepo.ActivateUser(ctx, id)
}

// DeactivateUser deactivates a user
func (us *UserService) DeactivateUser(ctx context.Context, id uint) error {
	return us.userRepo.DeactivateUser(ctx, id)
}

// SearchUsers searches users by query
func (us *UserService) SearchUsers(ctx context.Context, query string, page, pageSize int) (*models.PaginationResponse, error) {
	if page <= 0 {
		page = 1
	}
	if pageSize <= 0 {
		pageSize = 10
	}

	users, total, err := us.userRepo.SearchUsers(ctx, query, page, pageSize)
	if err != nil {
		return nil, err
	}

	// Convert to response format
	var userResponses []*models.UserResponse
	for _, user := range users {
		userResponses = append(userResponses, user.ToResponse())
	}

	totalPages := int(total) / pageSize
	if int(total)%pageSize > 0 {
		totalPages++
	}

	return &models.PaginationResponse{
		Page:       page,
		PageSize:   pageSize,
		Total:      total,
		TotalPages: totalPages,
		Data:       userResponses,
	}, nil
}

// GetActiveUsers retrieves all active users
func (us *UserService) GetActiveUsers(ctx context.Context) ([]*models.UserResponse, error) {
	users, err := us.userRepo.GetActiveUsers(ctx)
	if err != nil {
		return nil, err
	}

	var userResponses []*models.UserResponse
	for _, user := range users {
		userResponses = append(userResponses, user.ToResponse())
	}

	return userResponses, nil
}

// GetInactiveUsers retrieves all inactive users
func (us *UserService) GetInactiveUsers(ctx context.Context) ([]*models.UserResponse, error) {
	users, err := us.userRepo.GetInactiveUsers(ctx)
	if err != nil {
		return nil, err
	}

	var userResponses []*models.UserResponse
	for _, user := range users {
		userResponses = append(userResponses, user.ToResponse())
	}

	return userResponses, nil
}

// GetUserCount retrieves the total number of users
func (us *UserService) GetUserCount(ctx context.Context) (int64, error) {
	return us.userRepo.GetUserCount(ctx)
}

// GetActiveUserCount retrieves the number of active users
func (us *UserService) GetActiveUserCount(ctx context.Context) (int64, error) {
	return us.userRepo.GetActiveUserCount(ctx)
}

// GetInactiveUserCount retrieves the number of inactive users
func (us *UserService) GetInactiveUserCount(ctx context.Context) (int64, error) {
	return us.userRepo.GetInactiveUserCount(ctx)
}

{{- if .WithAuth}}

// AuthService handles authentication-related business logic
type AuthService struct {
	*Service
}

// NewAuthService creates a new auth service
func NewAuthService(service *Service) *AuthService {
	return &AuthService{Service: service}
}

// Authenticate authenticates a user
func (as *AuthService) Authenticate(ctx context.Context, req *models.LoginRequest) (*microservices.AuthResponse, error) {
	// Get user by username
	user, err := as.userRepo.GetUserByUsername(ctx, req.Username)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Check password
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Check if user is active
	if !user.IsActive {
		return nil, errors.New("user account is inactive")
	}

	// Use go-micro-libs auth library
	authReq := &microservices.AuthRequest{
		Username: req.Username,
		Password: req.Password,
	}

	authResp, err := as.authManager.Authenticate(ctx, "jwt", authReq)
	if err != nil {
		return nil, err
	}

	return authResp, nil
}

// ValidateToken validates a JWT token
func (as *AuthService) ValidateToken(ctx context.Context, token string) (*microservices.TokenValidationResponse, error) {
	// Use go-micro-libs auth library
	validateReq := &microservices.TokenValidationRequest{
		Token: token,
	}

	validateResp, err := as.authManager.ValidateToken(ctx, "jwt", validateReq)
	if err != nil {
		return nil, err
	}

	return validateResp, nil
}

// RefreshToken refreshes a JWT token
func (as *AuthService) RefreshToken(ctx context.Context, refreshToken string) (*microservices.AuthResponse, error) {
	// Use go-micro-libs auth library
	refreshReq := &microservices.RefreshTokenRequest{
		RefreshToken: refreshToken,
	}

	authResp, err := as.authManager.RefreshToken(ctx, "jwt", refreshReq)
	if err != nil {
		return nil, err
	}

	return authResp, nil
}

// RevokeToken revokes a JWT token
func (as *AuthService) RevokeToken(ctx context.Context, token string) error {
	// Use go-micro-libs auth library
	revokeReq := &microservices.RevokeTokenRequest{
		Token: token,
	}

	err := as.authManager.RevokeToken(ctx, "jwt", revokeReq)
	if err != nil {
		return err
	}

	return nil
}

// Authorize checks if a user is authorized to perform an action
func (as *AuthService) Authorize(ctx context.Context, userID string, resource string, action string) error {
	// Use go-micro-libs auth library
	authorizeReq := &microservices.AuthorizeRequest{
		UserID:   userID,
		Resource: resource,
		Action:   action,
	}

	err := as.authManager.Authorize(ctx, "jwt", authorizeReq)
	if err != nil {
		return err
	}

	return nil
}

// CheckPermission checks if a user has a specific permission
func (as *AuthService) CheckPermission(ctx context.Context, userID string, permission string) error {
	// Use go-micro-libs auth library
	permissionReq := &microservices.CheckPermissionRequest{
		UserID:     userID,
		Permission: permission,
	}

	err := as.authManager.CheckPermission(ctx, "jwt", permissionReq)
	if err != nil {
		return err
	}

	return nil
}

{{- end}}

{{- if .WithAPI}}

// APIService handles API thirdparty integration
type APIService struct {
	*Service
}

// NewAPIService creates a new API service
func NewAPIService(service *Service) *APIService {
	return &APIService{Service: service}
}

// SendHTTPRequest sends an HTTP request using the API manager
func (as *APIService) SendHTTPRequest(ctx context.Context, method, url string, headers map[string]string, body interface{}) (*microservices.APIResponse, error) {
	// Create API request
	apiReq := &microservices.APIRequest{
		Method:  method,
		URL:     url,
		Headers: headers,
		Body:    body,
	}

	// Send request using API manager
	response, err := as.apiManager.SendRequest(ctx, "http", apiReq)
	if err != nil {
		return nil, err
	}

	return response, nil
}

// SendGraphQLRequest sends a GraphQL request using the API manager
func (as *APIService) SendGraphQLRequest(ctx context.Context, query string, variables map[string]interface{}) (*microservices.GraphQLResponse, error) {
	// Create GraphQL request
	graphqlReq := &microservices.GraphQLRequest{
		Query:     query,
		Variables: variables,
	}

	// Send request using API manager
	response, err := as.apiManager.SendGraphQLRequest(ctx, "graphql", graphqlReq)
	if err != nil {
		return nil, err
	}

	return response, nil
}

// SendgRPCRequest sends a gRPC request using the API manager
func (as *APIService) SendgRPCRequest(ctx context.Context, service, method string, data interface{}) (*microservices.GRPCResponse, error) {
	// Create gRPC request
	grpcReq := &microservices.GRPCRequest{
		Service: service,
		Method:  method,
		Data:    data,
	}

	// Send request using API manager
	response, err := as.apiManager.SendgRPCRequest(ctx, "grpc", grpcReq)
	if err != nil {
		return nil, err
	}

	return response, nil
}

// ConnectWebSocket connects to a WebSocket using the API manager
func (as *APIService) ConnectWebSocket(ctx context.Context, url string, headers map[string]string) (*microservices.WebSocketResponse, error) {
	// Create WebSocket request
	wsReq := &microservices.WebSocketRequest{
		URL:     url,
		Headers: headers,
	}

	// Connect using API manager
	response, err := as.apiManager.ConnectWebSocket(ctx, "websocket", wsReq)
	if err != nil {
		return nil, err
	}

	return response, nil
}

{{- end}}

{{- if .WithEmail}}

// EmailService handles email operations
type EmailService struct {
	*Service
}

// NewEmailService creates a new email service
func NewEmailService(service *Service) *EmailService {
	return &EmailService{Service: service}
}

// SendEmail sends an email using the email manager
func (es *EmailService) SendEmail(ctx context.Context, to, subject, body string, isHTML bool) (*microservices.SendResponse, error) {
	// Create email message
	message := &microservices.EmailMessage{
		To:      []*microservices.EmailAddress{{Address: to}},
		Subject: subject,
		Body:    body,
		HTMLBody: body,
	}

	// Create send request
	sendReq := &microservices.SendRequest{
		Message: message,
	}

	// Send email using email manager
	response, err := es.emailManager.SendEmail(ctx, "smtp", sendReq)
	if err != nil {
		return nil, err
	}

	return response, nil
}

// SendEmailWithTemplate sends an email using a template
func (es *EmailService) SendEmailWithTemplate(ctx context.Context, to, templateID string, data map[string]interface{}) (*microservices.SendResponse, error) {
	// Create email message with template
	message := &microservices.EmailMessage{
		To:         []*microservices.EmailAddress{{Address: to}},
		TemplateID: templateID,
		Data:       data,
	}

	// Create send request
	sendReq := &microservices.SendRequest{
		Message: message,
	}

	// Send email using email manager
	response, err := es.emailManager.SendEmail(ctx, "smtp", sendReq)
	if err != nil {
		return nil, err
	}

	return response, nil
}

// SendBatchEmails sends multiple emails
func (es *EmailService) SendBatchEmails(ctx context.Context, emails []*microservices.EmailMessage) (*microservices.SendBatchResponse, error) {
	// Create batch request
	batchReq := &microservices.SendBatchRequest{
		Messages: emails,
	}

	// Send batch emails using email manager
	response, err := es.emailManager.SendBatch(ctx, "smtp", batchReq)
	if err != nil {
		return nil, err
	}

	return response, nil
}

// CreateEmailTemplate creates an email template
func (es *EmailService) CreateEmailTemplate(ctx context.Context, templateID, name, subject, body string) error {
	// Create template
	template := &microservices.Template{
		ID:      templateID,
		Name:    name,
		Subject: subject,
		Body:    body,
	}

	// Create template request
	templateReq := &microservices.CreateTemplateRequest{
		Template: template,
	}

	// Create template using email manager
	err := es.emailManager.CreateTemplate(ctx, "smtp", templateReq)
	if err != nil {
		return err
	}

	return nil
}

// GetEmailTemplate retrieves an email template
func (es *EmailService) GetEmailTemplate(ctx context.Context, templateID string) (*microservices.Template, error) {
	// Create get template request
	getReq := &microservices.GetTemplateRequest{
		ID: templateID,
	}

	// Get template using email manager
	template, err := es.emailManager.GetTemplate(ctx, "smtp", getReq)
	if err != nil {
		return nil, err
	}

	return template, nil
}

{{- end}}

// HealthService handles health check operations
type HealthService struct {
	*Service
}

// NewHealthService creates a new health service
func NewHealthService(service *Service) *HealthService {
	return &HealthService{Service: service}
}

// GetHealthStatus returns the health status of the service
func (hs *HealthService) GetHealthStatus(ctx context.Context) *models.HealthCheckResponse {
	// Get user count
	userCount, err := hs.userRepo.GetUserCount(ctx)
	if err != nil {
		return &models.HealthCheckResponse{
			Status:    "unhealthy",
			Service:   "{{.ServiceName}}",
			Version:   "1.0.0",
			Timestamp: "2024-01-01T00:00:00Z",
			Details: map[string]interface{}{
				"error": err.Error(),
			},
		}
	}

	// Get active user count
	activeUserCount, err := hs.userRepo.GetActiveUserCount(ctx)
	if err != nil {
		return &models.HealthCheckResponse{
			Status:    "unhealthy",
			Service:   "{{.ServiceName}}",
			Version:   "1.0.0",
			Timestamp: "2024-01-01T00:00:00Z",
			Details: map[string]interface{}{
				"error": err.Error(),
			},
		}
	}

	return &models.HealthCheckResponse{
		Status:    "healthy",
		Service:   "{{.ServiceName}}",
		Version:   "1.0.0",
		Timestamp: "2024-01-01T00:00:00Z",
		Details: map[string]interface{}{
			"total_users":  userCount,
			"active_users": activeUserCount,
		},
	}
}
