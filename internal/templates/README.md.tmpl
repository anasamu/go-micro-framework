# {{.ServiceName}}

A microservice built with the Go Micro Framework, integrating various microservices libraries for robust, scalable, and maintainable service architecture.

## Features

- **RESTful API**: Clean HTTP REST endpoints with proper status codes and error handling
- **Database Integration**: {{- if .WithDatabase}}PostgreSQL and Redis support{{- else}}No database configured{{- end}}
- **Authentication**: {{- if .WithAuth}}JWT and OAuth2 authentication{{- else}}No authentication configured{{- end}}
- **Monitoring**: {{- if .WithMonitoring}}Prometheus, Jaeger, and Grafana integration{{- else}}No monitoring configured{{- end}}
- **Messaging**: {{- if .WithMessaging}}Kafka and RabbitMQ support{{- else}}No messaging configured{{- end}}
- **Caching**: {{- if .WithCache}}Redis and in-memory caching{{- else}}No caching configured{{- end}}
- **Service Discovery**: {{- if .WithDiscovery}}Consul and Kubernetes discovery{{- else}}No discovery configured{{- end}}
- **Circuit Breaker**: {{- if .WithCircuitBreaker}}Resilience patterns{{- else}}No circuit breaker configured{{- end}}
- **Rate Limiting**: {{- if .WithRateLimit}}Request rate limiting{{- else}}No rate limiting configured{{- end}}
- **AI Integration**: {{- if .WithAI}}OpenAI and Anthropic support{{- else}}No AI configured{{- end}}
- **Storage**: {{- if .WithStorage}}S3 and GCS object storage{{- else}}No storage configured{{- end}}
- **Scheduling**: {{- if .WithScheduling}}Cron and Redis-based scheduling{{- else}}No scheduling configured{{- end}}
- **Backup**: {{- if .WithBackup}}Automated backup to cloud storage{{- else}}No backup configured{{- end}}
- **Chaos Engineering**: {{- if .WithChaos}}Chaos monkey for resilience testing{{- else}}No chaos engineering configured{{- end}}
- **Failover**: {{- if .WithFailover}}Automatic failover mechanisms{{- else}}No failover configured{{- end}}
- **Event Sourcing**: {{- if .WithEvent}}Event-driven architecture{{- else}}No event sourcing configured{{- end}}
- **Payment Processing**: {{- if .WithPayment}}Stripe and PayPal integration{{- else}}No payment processing configured{{- end}}
- **File Generation**: {{- if .WithFileGen}}Template-based file generation{{- else}}No file generation configured{{- end}}

## Architecture

This service follows the microservices architecture pattern with:

- **Clean Architecture**: Separation of concerns with handlers, services, and repositories
- **Dependency Injection**: Loose coupling between components
- **Interface-based Design**: Easy testing and mocking
- **Configuration Management**: Environment-based configuration
- **Health Checks**: Built-in health monitoring
- **Graceful Shutdown**: Proper resource cleanup

## Project Structure

```
{{.ServiceName}}/
├── cmd/
│   └── main.go                 # Application entry point
├── internal/
│   ├── handlers/               # HTTP request handlers
│   ├── models/                 # Data models and DTOs
│   ├── repositories/           # Data access layer
│   ├── services/               # Business logic layer
│   └── middleware/             # HTTP middleware
├── pkg/
│   └── types/                  # Public types and interfaces
├── configs/
│   ├── config.yaml             # Default configuration
│   ├── config.dev.yaml         # Development configuration
│   └── config.prod.yaml        # Production configuration
├── deployments/
│   ├── docker/
│   │   ├── Dockerfile          # Docker container definition
│   │   └── docker-compose.yml  # Docker Compose setup
│   ├── kubernetes/
│   │   ├── deployment.yaml     # Kubernetes deployment
│   │   ├── service.yaml        # Kubernetes service
│   │   └── configmap.yaml      # Kubernetes configuration
│   └── helm/
│       └── Chart.yaml          # Helm chart definition
├── tests/
│   ├── unit/                   # Unit tests
│   ├── integration/            # Integration tests
│   └── e2e/                    # End-to-end tests
├── docs/
│   ├── API.md                  # API documentation
│   └── DEPLOYMENT.md           # Deployment guide
├── scripts/
│   ├── build.sh                # Build script
│   ├── test.sh                 # Test script
│   └── deploy.sh               # Deployment script
├── go.mod                      # Go module dependencies
├── go.sum                      # Go module checksums
├── Makefile                    # Build automation
└── README.md                   # This file
```

## Quick Start

### Prerequisites

- Go 1.21 or newer
- {{- if .WithDatabase}}PostgreSQL 15+{{- end}}
- {{- if .WithDatabase}}Redis 7+{{- end}}
- {{- if .WithMessaging}}Kafka 3+{{- end}}
- {{- if .WithMessaging}}RabbitMQ 3.11+{{- end}}
- {{- if .WithMonitoring}}Prometheus 2.40+{{- end}}
- {{- if .WithMonitoring}}Jaeger 1.40+{{- end}}
- {{- if .WithMonitoring}}Grafana 9.0+{{- end}}
- {{- if .WithDiscovery}}Consul 1.14+{{- end}}

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd {{.ServiceName}}
```

2. Install dependencies:
```bash
go mod download
```

3. Set up environment variables:
```bash
cp .env.example .env
# Edit .env with your configuration
```

4. {{- if .WithDatabase}}Set up the database:
```bash
# PostgreSQL
createdb {{.ServiceName}}

# Redis
redis-server
```
{{- end}}

5. Run the service:
```bash
go run cmd/main.go
```

The service will start on `http://localhost:8080`

### Using Docker

1. Build the Docker image:
```bash
docker build -f deployments/docker/Dockerfile -t {{.ServiceName}} .
```

2. Run with Docker Compose:
```bash
cd deployments/docker
docker-compose up -d
```

### Using Kubernetes

1. Apply Kubernetes manifests:
```bash
kubectl apply -f deployments/kubernetes/
```

2. Check deployment status:
```bash
kubectl get pods -l app={{.ServiceName}}
```

## Configuration

The service uses YAML configuration files with environment variable substitution. Key configuration sections:

### Service Configuration
```yaml
service:
  name: "{{.ServiceName}}"
  version: "1.0.0"
  port: 8080
  environment: "development"
```

### {{- if .WithDatabase}}
### Database Configuration
```yaml
database:
  providers:
    postgresql:
      url: "${DATABASE_URL}"
      max_connections: 100
      max_idle_connections: 10
    redis:
      url: "${REDIS_URL}"
      db: 0
      pool_size: 10
```
{{- end}}

### {{- if .WithAuth}}
### Authentication Configuration
```yaml
auth:
  providers:
    jwt:
      secret: "${JWT_SECRET}"
      expiration: "24h"
      issuer: "{{.ServiceName}}"
    oauth:
      client_id: "${OAUTH_CLIENT_ID}"
      client_secret: "${OAUTH_CLIENT_SECRET}"
```
{{- end}}

### {{- if .WithMonitoring}}
### Monitoring Configuration
```yaml
monitoring:
  providers:
    prometheus:
      endpoint: "${PROMETHEUS_ENDPOINT}"
      port: 9090
    jaeger:
      endpoint: "${JAEGER_ENDPOINT}"
      service_name: "{{.ServiceName}}"
```
{{- end}}

## API Documentation

### Health Check
```http
GET /health
```

Returns the health status of the service.

### Ping
```http
GET /api/v1/ping
```

Returns a simple pong response.

### {{- if .WithAuth}}
### Authentication Endpoints

#### Login
```http
POST /api/v1/auth/login
Content-Type: application/json

{
  "username": "your-username",
  "password": "your-password"
}
```

#### Register
```http
POST /api/v1/auth/register
Content-Type: application/json

{
  "username": "new-user",
  "email": "user@example.com",
  "password": "secure-password",
  "first_name": "John",
  "last_name": "Doe"
}
```

#### Refresh Token
```http
POST /api/v1/auth/refresh
Content-Type: application/json

{
  "refresh_token": "your-refresh-token"
}
```

#### Logout
```http
POST /api/v1/auth/logout
Content-Type: application/json
Authorization: Bearer <access-token>

{
  "access_token": "your-access-token"
}
```
{{- end}}

### User Management Endpoints

#### Get All Users
```http
GET /api/v1/users
{{- if .WithAuth}}
Authorization: Bearer <access-token>
{{- end}}
```

#### Get User by ID
```http
GET /api/v1/users/{id}
{{- if .WithAuth}}
Authorization: Bearer <access-token>
{{- end}}
```

#### Create User
```http
POST /api/v1/users
Content-Type: application/json
{{- if .WithAuth}}
Authorization: Bearer <access-token>
{{- end}}

{
  "username": "new-user",
  "email": "user@example.com",
  "password": "secure-password",
  "first_name": "John",
  "last_name": "Doe"
}
```

#### Update User
```http
PUT /api/v1/users/{id}
Content-Type: application/json
{{- if .WithAuth}}
Authorization: Bearer <access-token>
{{- end}}

{
  "first_name": "Updated",
  "last_name": "Name"
}
```

#### Delete User
```http
DELETE /api/v1/users/{id}
{{- if .WithAuth}}
Authorization: Bearer <access-token>
{{- end}}
```

## Development

### Running Tests

```bash
# Run all tests
make test

# Run unit tests only
make test-unit

# Run integration tests only
make test-integration

# Run tests with coverage
make test-coverage
```

### Code Quality

```bash
# Format code
make fmt

# Lint code
make lint

# Run security scan
make security
```

### Building

```bash
# Build for current platform
make build

# Build for multiple platforms
make build-all

# Build Docker image
make docker-build
```

## Deployment

### Environment Variables

Required environment variables:

- `DATABASE_URL`: {{- if .WithDatabase}}PostgreSQL connection string{{- else}}Not required{{- end}}
- `REDIS_URL`: {{- if .WithDatabase}}Redis connection string{{- else}}Not required{{- end}}
- `JWT_SECRET`: {{- if .WithAuth}}JWT signing secret{{- else}}Not required{{- end}}
- `OAUTH_CLIENT_ID`: {{- if .WithAuth}}OAuth2 client ID{{- else}}Not required{{- end}}
- `OAUTH_CLIENT_SECRET`: {{- if .WithAuth}}OAuth2 client secret{{- else}}Not required{{- end}}
- `PROMETHEUS_ENDPOINT`: {{- if .WithMonitoring}}Prometheus endpoint{{- else}}Not required{{- end}}
- `JAEGER_ENDPOINT`: {{- if .WithMonitoring}}Jaeger endpoint{{- else}}Not required{{- end}}
- `KAFKA_BROKERS`: {{- if .WithMessaging}}Kafka broker addresses{{- else}}Not required{{- end}}
- `RABBITMQ_URL`: {{- if .WithMessaging}}RabbitMQ connection string{{- else}}Not required{{- end}}

### Docker Deployment

1. Build the image:
```bash
docker build -t {{.ServiceName}}:latest .
```

2. Run the container:
```bash
docker run -d \
  --name {{.ServiceName}} \
  -p 8080:8080 \
  -e DATABASE_URL=postgres://user:pass@localhost/{{.ServiceName}} \
  {{.ServiceName}}:latest
```

### Kubernetes Deployment

1. Create secrets:
```bash
kubectl create secret generic {{.ServiceName}}-secrets \
  --from-literal=database-url=postgres://user:pass@postgres/{{.ServiceName}} \
  --from-literal=redis-url=redis://redis:6379/0 \
  --from-literal=jwt-secret=your-jwt-secret
```

2. Apply manifests:
```bash
kubectl apply -f deployments/kubernetes/
```

3. Check deployment:
```bash
kubectl get pods -l app={{.ServiceName}}
```

## Monitoring

### {{- if .WithMonitoring}}
### Health Checks

The service provides health check endpoints:

- `/health`: Basic health status
- `/metrics`: Prometheus metrics
- `/debug/pprof`: Go profiling endpoints

### Metrics

Key metrics exposed:

- `http_requests_total`: Total HTTP requests
- `http_request_duration_seconds`: Request duration
- `http_requests_in_flight`: Requests currently being processed
- `database_connections_active`: Active database connections
- `cache_hits_total`: Cache hit count
- `cache_misses_total`: Cache miss count

### Logging

Structured logging with correlation IDs for request tracing.

### Tracing

Distributed tracing with Jaeger for request flow analysis.
{{- else}}
### Health Checks

The service provides basic health check endpoints:

- `/health`: Basic health status

### Logging

Basic logging with request information.
{{- end}}

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Support

For support and questions:

- Create an issue in the repository
- Check the documentation in the `docs/` directory
- Review the API documentation in `docs/API.md`

## Changelog

### v1.0.0
- Initial release
- Basic CRUD operations for users
- {{- if .WithAuth}}JWT authentication{{- end}}
- {{- if .WithDatabase}}PostgreSQL and Redis integration{{- end}}
- {{- if .WithMonitoring}}Prometheus metrics{{- end}}
- Docker and Kubernetes deployment support
