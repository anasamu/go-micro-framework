package handlers

import (
	"context"
	"time"

	"github.com/graphql-go/graphql"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	// Generated protobuf files
	pb "{{.ServiceName}}/protobuf"
	
	// Generated services
	"{{.ServiceName}}/internal/services"
)

// {{.ServiceName}}Handler handles both gRPC and GraphQL requests for {{.ServiceName}}
type {{.ServiceName}}Handler struct {
	pb.Unimplemented{{.ServiceName}}ServiceServer
	service *services.{{.ServiceName}}Service
	logger  *logrus.Logger
}

// New{{.ServiceName}}Handler creates a new {{.ServiceName}} handler
func New{{.ServiceName}}Handler(service *services.{{.ServiceName}}Service, logger *logrus.Logger) *{{.ServiceName}}Handler {
	return &{{.ServiceName}}Handler{
		service: service,
		logger:  logger,
	}
}

// gRPC Methods

// HealthCheck implements the health check gRPC method
func (h *{{.ServiceName}}Handler) HealthCheck(ctx context.Context, req *pb.HealthCheckRequest) (*pb.HealthResponse, error) {
	h.logger.Info("Health check requested")
	
	return &pb.HealthResponse{
		Status:    "healthy",
		Message:   "{{.ServiceName}} service is running",
		Timestamp: timestamppb.New(time.Now()),
	}, nil
}

// GetServiceInfo implements the service info gRPC method
func (h *{{.ServiceName}}Handler) GetServiceInfo(ctx context.Context, req *pb.GetServiceInfoRequest) (*pb.ServiceInfoResponse, error) {
	h.logger.Info("Service info requested")
	
	return &pb.ServiceInfoResponse{
		Name:        "{{.ServiceName}}",
		Version:     "1.0.0",
		Description: "{{.ServiceName}} microservice",
		StartedAt:   timestamppb.New(time.Now()),
	}, nil
}

// Create{{.ServiceName}} implements the create {{.ServiceName}} gRPC method
func (h *{{.ServiceName}}Handler) Create{{.ServiceName}}(ctx context.Context, req *pb.Create{{.ServiceName}}Request) (*pb.{{.ServiceName}}Response, error) {
	h.logger.WithFields(logrus.Fields{
		"name":        req.Name,
		"description": req.Description,
	}).Info("Create {{.ServiceName}} requested")
	
	// Validate request
	if req.Name == "" {
		return nil, status.Error(codes.InvalidArgument, "name is required")
	}
	
	// Create {{.ServiceName}} using service
	{{.ServiceName | lower}}, err := h.service.Create{{.ServiceName}}(ctx, req.Name, req.Description)
	if err != nil {
		h.logger.WithError(err).Error("Failed to create {{.ServiceName}}")
		return nil, status.Error(codes.Internal, "failed to create {{.ServiceName}}")
	}
	
	// Convert to protobuf response
	pb{{.ServiceName}} := &pb.{{.ServiceName}}{
		Id:          {{.ServiceName | lower}}.ID,
		Name:        {{.ServiceName | lower}}.Name,
		Description: {{.ServiceName | lower}}.Description,
		CreatedAt:   timestamppb.New({{.ServiceName | lower}}.CreatedAt),
		UpdatedAt:   timestamppb.New({{.ServiceName | lower}}.UpdatedAt),
	}
	
	return &pb.{{.ServiceName}}Response{
		{{.ServiceName | lower}}: pb{{.ServiceName}},
		Message: "{{.ServiceName}} created successfully",
		Success: true,
	}, nil
}

// Get{{.ServiceName}} implements the get {{.ServiceName}} gRPC method
func (h *{{.ServiceName}}Handler) Get{{.ServiceName}}(ctx context.Context, req *pb.Get{{.ServiceName}}Request) (*pb.{{.ServiceName}}Response, error) {
	h.logger.WithField("id", req.Id).Info("Get {{.ServiceName}} requested")
	
	// Validate request
	if req.Id == "" {
		return nil, status.Error(codes.InvalidArgument, "id is required")
	}
	
	// Get {{.ServiceName}} using service
	{{.ServiceName | lower}}, err := h.service.Get{{.ServiceName}}(ctx, req.Id)
	if err != nil {
		h.logger.WithError(err).Error("Failed to get {{.ServiceName}}")
		return nil, status.Error(codes.NotFound, "{{.ServiceName}} not found")
	}
	
	// Convert to protobuf response
	pb{{.ServiceName}} := &pb.{{.ServiceName}}{
		Id:          {{.ServiceName | lower}}.ID,
		Name:        {{.ServiceName | lower}}.Name,
		Description: {{.ServiceName | lower}}.Description,
		CreatedAt:   timestamppb.New({{.ServiceName | lower}}.CreatedAt),
		UpdatedAt:   timestamppb.New({{.ServiceName | lower}}.UpdatedAt),
	}
	
	return &pb.{{.ServiceName}}Response{
		{{.ServiceName | lower}}: pb{{.ServiceName}},
		Message: "{{.ServiceName}} retrieved successfully",
		Success: true,
	}, nil
}

// Update{{.ServiceName}} implements the update {{.ServiceName}} gRPC method
func (h *{{.ServiceName}}Handler) Update{{.ServiceName}}(ctx context.Context, req *pb.Update{{.ServiceName}}Request) (*pb.{{.ServiceName}}Response, error) {
	h.logger.WithFields(logrus.Fields{
		"id":          req.Id,
		"name":        req.Name,
		"description": req.Description,
	}).Info("Update {{.ServiceName}} requested")
	
	// Validate request
	if req.Id == "" {
		return nil, status.Error(codes.InvalidArgument, "id is required")
	}
	
	// Update {{.ServiceName}} using service
	{{.ServiceName | lower}}, err := h.service.Update{{.ServiceName}}(ctx, req.Id, req.Name, req.Description)
	if err != nil {
		h.logger.WithError(err).Error("Failed to update {{.ServiceName}}")
		return nil, status.Error(codes.Internal, "failed to update {{.ServiceName}}")
	}
	
	// Convert to protobuf response
	pb{{.ServiceName}} := &pb.{{.ServiceName}}{
		Id:          {{.ServiceName | lower}}.ID,
		Name:        {{.ServiceName | lower}}.Name,
		Description: {{.ServiceName | lower}}.Description,
		CreatedAt:   timestamppb.New({{.ServiceName | lower}}.CreatedAt),
		UpdatedAt:   timestamppb.New({{.ServiceName | lower}}.UpdatedAt),
	}
	
	return &pb.{{.ServiceName}}Response{
		{{.ServiceName | lower}}: pb{{.ServiceName}},
		Message: "{{.ServiceName}} updated successfully",
		Success: true,
	}, nil
}

// Delete{{.ServiceName}} implements the delete {{.ServiceName}} gRPC method
func (h *{{.ServiceName}}Handler) Delete{{.ServiceName}}(ctx context.Context, req *pb.Delete{{.ServiceName}}Request) (*pb.Delete{{.ServiceName}}Response, error) {
	h.logger.WithField("id", req.Id).Info("Delete {{.ServiceName}} requested")
	
	// Validate request
	if req.Id == "" {
		return nil, status.Error(codes.InvalidArgument, "id is required")
	}
	
	// Delete {{.ServiceName}} using service
	err := h.service.Delete{{.ServiceName}}(ctx, req.Id)
	if err != nil {
		h.logger.WithError(err).Error("Failed to delete {{.ServiceName}}")
		return nil, status.Error(codes.Internal, "failed to delete {{.ServiceName}}")
	}
	
	return &pb.Delete{{.ServiceName}}Response{
		Message: "{{.ServiceName}} deleted successfully",
		Success: true,
	}, nil
}

// List{{.ServiceName}}s implements the list {{.ServiceName}}s gRPC method
func (h *{{.ServiceName}}Handler) List{{.ServiceName}}s(ctx context.Context, req *pb.List{{.ServiceName}}sRequest) (*pb.List{{.ServiceName}}sResponse, error) {
	h.logger.WithFields(logrus.Fields{
		"page":   req.Page,
		"limit":  req.Limit,
		"search": req.Search,
	}).Info("List {{.ServiceName}}s requested")
	
	// Set default values
	page := req.Page
	if page <= 0 {
		page = 1
	}
	
	limit := req.Limit
	if limit <= 0 {
		limit = 10
	}
	
	// List {{.ServiceName}}s using service
	{{.ServiceName | lower}}s, total, err := h.service.List{{.ServiceName}}s(ctx, page, limit, req.Search)
	if err != nil {
		h.logger.WithError(err).Error("Failed to list {{.ServiceName}}s")
		return nil, status.Error(codes.Internal, "failed to list {{.ServiceName}}s")
	}
	
	// Convert to protobuf response
	pb{{.ServiceName}}s := make([]*pb.{{.ServiceName}}, 0, len({{.ServiceName | lower}}s))
	for _, {{.ServiceName | lower}} := range {{.ServiceName | lower}}s {
		pb{{.ServiceName}} := &pb.{{.ServiceName}}{
			Id:          {{.ServiceName | lower}}.ID,
			Name:        {{.ServiceName | lower}}.Name,
			Description: {{.ServiceName | lower}}.Description,
			CreatedAt:   timestamppb.New({{.ServiceName | lower}}.CreatedAt),
			UpdatedAt:   timestamppb.New({{.ServiceName | lower}}.UpdatedAt),
		}
		pb{{.ServiceName}}s = append(pb{{.ServiceName}}s, pb{{.ServiceName}})
	}
	
	return &pb.List{{.ServiceName}}sResponse{
		{{.ServiceName | lower}}s: pb{{.ServiceName}}s,
		Total:   int32(total),
		Page:    int32(page),
		Limit:   int32(limit),
		Message: "{{.ServiceName}}s retrieved successfully",
		Success: true,
	}, nil
}

// GraphQL Methods

// GetGraphQLSchema returns the GraphQL schema for {{.ServiceName}}
func (h *{{.ServiceName}}Handler) GetGraphQLSchema() (*graphql.Schema, error) {
	// Define scalar types
	timeType := graphql.NewScalar(graphql.ScalarConfig{
		Name:        "Time",
		Description: "Time scalar type",
		Serialize: func(value interface{}) interface{} {
			if t, ok := value.(time.Time); ok {
				return t.Format(time.RFC3339)
			}
			return nil
		},
		ParseValue: func(value interface{}) interface{} {
			if str, ok := value.(string); ok {
				if t, err := time.Parse(time.RFC3339, str); err == nil {
					return t
				}
			}
			return nil
		},
	})

	// Define {{.ServiceName}} type
	{{.ServiceName | lower}}Type := graphql.NewObject(graphql.ObjectConfig{
		Name:        "{{.ServiceName}}",
		Description: "{{.ServiceName}} type",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.ID),
				Description: "{{.ServiceName}} ID",
			},
			"name": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.String),
				Description: "{{.ServiceName}} name",
			},
			"description": &graphql.Field{
				Type:        graphql.String,
				Description: "{{.ServiceName}} description",
			},
			"createdAt": &graphql.Field{
				Type:        graphql.NewNonNull(timeType),
				Description: "Creation timestamp",
			},
			"updatedAt": &graphql.Field{
				Type:        graphql.NewNonNull(timeType),
				Description: "Last update timestamp",
			},
		},
	})

	// Define {{.ServiceName}} input type
	{{.ServiceName | lower}}InputType := graphql.NewInputObject(graphql.InputObjectConfig{
		Name:        "{{.ServiceName}}Input",
		Description: "{{.ServiceName}} input",
		Fields: graphql.InputObjectConfigFieldMap{
			"name": &graphql.InputObjectFieldConfig{
				Type:        graphql.NewNonNull(graphql.String),
				Description: "{{.ServiceName}} name",
			},
			"description": &graphql.InputObjectFieldConfig{
				Type:        graphql.String,
				Description: "{{.ServiceName}} description",
			},
		},
	})

	// Define {{.ServiceName}} update input type
	{{.ServiceName | lower}}UpdateInputType := graphql.NewInputObject(graphql.InputObjectConfig{
		Name:        "{{.ServiceName}}UpdateInput",
		Description: "{{.ServiceName}} update input",
		Fields: graphql.InputObjectConfigFieldMap{
			"id": &graphql.InputObjectFieldConfig{
				Type:        graphql.NewNonNull(graphql.ID),
				Description: "{{.ServiceName}} ID",
			},
			"name": &graphql.InputObjectFieldConfig{
				Type:        graphql.String,
				Description: "{{.ServiceName}} name",
			},
			"description": &graphql.InputObjectFieldConfig{
				Type:        graphql.String,
				Description: "{{.ServiceName}} description",
			},
		},
	})

	// Define response type
	responseType := graphql.NewObject(graphql.ObjectConfig{
		Name:        "Response",
		Description: "Response type",
		Fields: graphql.Fields{
			"success": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.Boolean),
				Description: "Success status",
			},
			"message": &graphql.Field{
				Type:        graphql.String,
				Description: "Response message",
			},
			"errors": &graphql.Field{
				Type:        graphql.NewList(graphql.NewNonNull(graphql.String)),
				Description: "Error messages",
			},
		},
	})

	// Define pagination info type
	paginationInfoType := graphql.NewObject(graphql.ObjectConfig{
		Name:        "PaginationInfo",
		Description: "Pagination info",
		Fields: graphql.Fields{
			"page": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.Int),
				Description: "Current page",
			},
			"limit": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.Int),
				Description: "Items per page",
			},
			"total": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.Int),
				Description: "Total items",
			},
			"totalPages": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.Int),
				Description: "Total pages",
			},
		},
	})

	// Define {{.ServiceName}} list response type
	{{.ServiceName | lower}}ListResponseType := graphql.NewObject(graphql.ObjectConfig{
		Name:        "{{.ServiceName}}ListResponse",
		Description: "{{.ServiceName}} list response",
		Fields: graphql.Fields{
			"{{.ServiceName | lower}}s": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.NewList(graphql.NewNonNull({{.ServiceName | lower}}Type))),
				Description: "List of {{.ServiceName}}s",
			},
			"pagination": &graphql.Field{
				Type:        graphql.NewNonNull(paginationInfoType),
				Description: "Pagination info",
			},
			"response": &graphql.Field{
				Type:        graphql.NewNonNull(responseType),
				Description: "Response info",
			},
		},
	})

	// Define health type
	healthType := graphql.NewObject(graphql.ObjectConfig{
		Name:        "Health",
		Description: "Health check type",
		Fields: graphql.Fields{
			"status": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.String),
				Description: "Health status",
			},
			"message": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.String),
				Description: "Health message",
			},
			"timestamp": &graphql.Field{
				Type:        graphql.NewNonNull(timeType),
				Description: "Health check timestamp",
			},
		},
	})

	// Define service info type
	serviceInfoType := graphql.NewObject(graphql.ObjectConfig{
		Name:        "ServiceInfo",
		Description: "Service info type",
		Fields: graphql.Fields{
			"name": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.String),
				Description: "Service name",
			},
			"version": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.String),
				Description: "Service version",
			},
			"description": &graphql.Field{
				Type:        graphql.NewNonNull(graphql.String),
				Description: "Service description",
			},
			"startedAt": &graphql.Field{
				Type:        graphql.NewNonNull(timeType),
				Description: "Service start time",
			},
		},
	})

	// Define query type
	queryType := graphql.NewObject(graphql.ObjectConfig{
		Name:        "Query",
		Description: "Query type",
		Fields: graphql.Fields{
			"health": &graphql.Field{
				Type:        graphql.NewNonNull(healthType),
				Description: "Health check",
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					return map[string]interface{}{
						"status":    "healthy",
						"message":   "{{.ServiceName}} service is running",
						"timestamp": time.Now(),
					}, nil
				},
			},
			"serviceInfo": &graphql.Field{
				Type:        graphql.NewNonNull(serviceInfoType),
				Description: "Service information",
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					return map[string]interface{}{
						"name":        "{{.ServiceName}}",
						"version":     "1.0.0",
						"description": "{{.ServiceName}} microservice",
						"startedAt":   time.Now(),
					}, nil
				},
			},
			"{{.ServiceName | lower}}": &graphql.Field{
				Type:        graphql.NewNonNull({{.ServiceName | lower}}Type),
				Description: "Get {{.ServiceName}} by ID",
				Args: graphql.FieldConfigArgument{
					"id": &graphql.ArgumentConfig{
						Type:        graphql.NewNonNull(graphql.ID),
						Description: "{{.ServiceName}} ID",
					},
				},
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					id := p.Args["id"].(string)
					
					{{.ServiceName | lower}}, err := h.service.Get{{.ServiceName}}(p.Context, id)
					if err != nil {
						h.logger.WithError(err).Error("Failed to get {{.ServiceName}}")
						return nil, err
					}
					
					return map[string]interface{}{
						"id":          {{.ServiceName | lower}}.ID,
						"name":        {{.ServiceName | lower}}.Name,
						"description": {{.ServiceName | lower}}.Description,
						"createdAt":   {{.ServiceName | lower}}.CreatedAt,
						"updatedAt":   {{.ServiceName | lower}}.UpdatedAt,
					}, nil
				},
			},
			"{{.ServiceName | lower}}s": &graphql.Field{
				Type:        graphql.NewNonNull({{.ServiceName | lower}}ListResponseType),
				Description: "List {{.ServiceName}}s",
				Args: graphql.FieldConfigArgument{
					"page": &graphql.ArgumentConfig{
						Type:        graphql.Int,
						Description: "Page number",
					},
					"limit": &graphql.ArgumentConfig{
						Type:        graphql.Int,
						Description: "Items per page",
					},
					"search": &graphql.ArgumentConfig{
						Type:        graphql.String,
						Description: "Search term",
					},
				},
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					page := 1
					if p.Args["page"] != nil {
						page = p.Args["page"].(int)
					}
					
					limit := 10
					if p.Args["limit"] != nil {
						limit = p.Args["limit"].(int)
					}
					
					search := ""
					if p.Args["search"] != nil {
						search = p.Args["search"].(string)
					}
					
					{{.ServiceName | lower}}s, total, err := h.service.List{{.ServiceName}}s(p.Context, page, limit, search)
					if err != nil {
						h.logger.WithError(err).Error("Failed to list {{.ServiceName}}s")
						return nil, err
					}
					
					// Convert to GraphQL response
					graphql{{.ServiceName}}s := make([]interface{}, 0, len({{.ServiceName | lower}}s))
					for _, {{.ServiceName | lower}} := range {{.ServiceName | lower}}s {
						graphql{{.ServiceName}}s = append(graphql{{.ServiceName}}s, map[string]interface{}{
							"id":          {{.ServiceName | lower}}.ID,
							"name":        {{.ServiceName | lower}}.Name,
							"description": {{.ServiceName | lower}}.Description,
							"createdAt":   {{.ServiceName | lower}}.CreatedAt,
							"updatedAt":   {{.ServiceName | lower}}.UpdatedAt,
						})
					}
					
					totalPages := (total + limit - 1) / limit
					
					return map[string]interface{}{
						"{{.ServiceName | lower}}s": graphql{{.ServiceName}}s,
						"pagination": map[string]interface{}{
							"page":       page,
							"limit":      limit,
							"total":      total,
							"totalPages": totalPages,
						},
						"response": map[string]interface{}{
							"success": true,
							"message": "{{.ServiceName}}s retrieved successfully",
							"errors":  []string{},
						},
					}, nil
				},
			},
		},
	})

	// Define mutation type
	mutationType := graphql.NewObject(graphql.ObjectConfig{
		Name:        "Mutation",
		Description: "Mutation type",
		Fields: graphql.Fields{
			"create{{.ServiceName}}": &graphql.Field{
				Type:        graphql.NewNonNull({{.ServiceName | lower}}Type),
				Description: "Create {{.ServiceName}}",
				Args: graphql.FieldConfigArgument{
					"input": &graphql.ArgumentConfig{
						Type:        graphql.NewNonNull({{.ServiceName | lower}}InputType),
						Description: "{{.ServiceName}} input",
					},
				},
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					input := p.Args["input"].(map[string]interface{})
					
					name := input["name"].(string)
					description := ""
					if input["description"] != nil {
						description = input["description"].(string)
					}
					
					{{.ServiceName | lower}}, err := h.service.Create{{.ServiceName}}(p.Context, name, description)
					if err != nil {
						h.logger.WithError(err).Error("Failed to create {{.ServiceName}}")
						return nil, err
					}
					
					return map[string]interface{}{
						"id":          {{.ServiceName | lower}}.ID,
						"name":        {{.ServiceName | lower}}.Name,
						"description": {{.ServiceName | lower}}.Description,
						"createdAt":   {{.ServiceName | lower}}.CreatedAt,
						"updatedAt":   {{.ServiceName | lower}}.UpdatedAt,
					}, nil
				},
			},
			"update{{.ServiceName}}": &graphql.Field{
				Type:        graphql.NewNonNull({{.ServiceName | lower}}Type),
				Description: "Update {{.ServiceName}}",
				Args: graphql.FieldConfigArgument{
					"input": &graphql.ArgumentConfig{
						Type:        graphql.NewNonNull({{.ServiceName | lower}}UpdateInputType),
						Description: "{{.ServiceName}} update input",
					},
				},
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					input := p.Args["input"].(map[string]interface{})
					
					id := input["id"].(string)
					name := ""
					if input["name"] != nil {
						name = input["name"].(string)
					}
					description := ""
					if input["description"] != nil {
						description = input["description"].(string)
					}
					
					{{.ServiceName | lower}}, err := h.service.Update{{.ServiceName}}(p.Context, id, name, description)
					if err != nil {
						h.logger.WithError(err).Error("Failed to update {{.ServiceName}}")
						return nil, err
					}
					
					return map[string]interface{}{
						"id":          {{.ServiceName | lower}}.ID,
						"name":        {{.ServiceName | lower}}.Name,
						"description": {{.ServiceName | lower}}.Description,
						"createdAt":   {{.ServiceName | lower}}.CreatedAt,
						"updatedAt":   {{.ServiceName | lower}}.UpdatedAt,
					}, nil
				},
			},
			"delete{{.ServiceName}}": &graphql.Field{
				Type:        graphql.NewNonNull(responseType),
				Description: "Delete {{.ServiceName}}",
				Args: graphql.FieldConfigArgument{
					"id": &graphql.ArgumentConfig{
						Type:        graphql.NewNonNull(graphql.ID),
						Description: "{{.ServiceName}} ID",
					},
				},
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					id := p.Args["id"].(string)
					
					err := h.service.Delete{{.ServiceName}}(p.Context, id)
					if err != nil {
						h.logger.WithError(err).Error("Failed to delete {{.ServiceName}}")
						return nil, err
					}
					
					return map[string]interface{}{
						"success": true,
						"message": "{{.ServiceName}} deleted successfully",
						"errors":  []string{},
					}, nil
				},
			},
		},
	})

	// Create schema
	schema, err := graphql.NewSchema(graphql.SchemaConfig{
		Query:    queryType,
		Mutation: mutationType,
	})

	if err != nil {
		return nil, err
	}

	return &schema, nil
}
