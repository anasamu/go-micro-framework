package middleware

import (
	"net/http"
	"strings"
	"time"

	"{{.ServiceName}}/internal/services"

	"github.com/anasamu/go-micro-libs"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

// Middleware provides middleware functions for the service
type Middleware struct {
	authService *services.AuthService
	logger      *logrus.Logger
}

// NewMiddleware creates a new middleware instance
func NewMiddleware(authService *services.AuthService) *Middleware {
	return &Middleware{
		authService: authService,
		logger:      logrus.New(),
	}
}

// AuthMiddleware provides authentication middleware
func (m *Middleware) AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Get authorization header
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authorization header"})
			c.Abort()
			return
		}

		// Extract token from "Bearer <token>"
		tokenParts := strings.Split(authHeader, " ")
		if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
			c.Abort()
			return
		}

		token := tokenParts[1]

		// Validate token using existing auth library
		validateResp, err := m.authService.ValidateToken(c.Request.Context(), token)
		if err != nil {
			m.logger.Error("Token validation failed:", err)
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		// Set user info in context
		c.Set("user_id", validateResp.UserID)
		c.Set("user_roles", validateResp.Roles)
		c.Set("user_permissions", validateResp.Permissions)

		c.Next()
	}
}

// OptionalAuthMiddleware provides optional authentication middleware
func (m *Middleware) OptionalAuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Get authorization header
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			// No auth header, continue without authentication
			c.Next()
			return
		}

		// Extract token from "Bearer <token>"
		tokenParts := strings.Split(authHeader, " ")
		if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
			// Invalid format, continue without authentication
			c.Next()
			return
		}

		token := tokenParts[1]

		// Validate token using existing auth library
		validateResp, err := m.authService.ValidateToken(c.Request.Context(), token)
		if err != nil {
			// Invalid token, continue without authentication
			c.Next()
			return
		}

		// Set user info in context
		c.Set("user_id", validateResp.UserID)
		c.Set("user_roles", validateResp.Roles)
		c.Set("user_permissions", validateResp.Permissions)

		c.Next()
	}
}

// RoleMiddleware provides role-based authorization middleware
func (m *Middleware) RoleMiddleware(requiredRoles ...string) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Get user roles from context
		userRoles, exists := c.Get("user_roles")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "User roles not found"})
			c.Abort()
			return
		}

		roles, ok := userRoles.([]string)
		if !ok {
			c.JSON(http.StatusForbidden, gin.H{"error": "Invalid user roles format"})
			c.Abort()
			return
		}

		// Check if user has required role
		hasRole := false
		for _, requiredRole := range requiredRoles {
			for _, userRole := range roles {
				if userRole == requiredRole {
					hasRole = true
					break
				}
			}
			if hasRole {
				break
			}
		}

		if !hasRole {
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// PermissionMiddleware provides permission-based authorization middleware
func (m *Middleware) PermissionMiddleware(requiredPermission string) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Get user ID from context
		userID, exists := c.Get("user_id")
		if !exists {
			c.JSON(http.StatusForbidden, gin.H{"error": "User ID not found"})
			c.Abort()
			return
		}

		userIDStr, ok := userID.(string)
		if !ok {
			c.JSON(http.StatusForbidden, gin.H{"error": "Invalid user ID format"})
			c.Abort()
			return
		}

		// Check permission using existing auth library
		err := m.authService.CheckPermission(c.Request.Context(), userIDStr, requiredPermission)
		if err != nil {
			m.logger.Error("Permission check failed:", err)
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// LoggingMiddleware provides request logging middleware
func (m *Middleware) LoggingMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		raw := c.Request.URL.RawQuery

		// Process request
		c.Next()

		// Log request details
		latency := time.Since(start)
		clientIP := c.ClientIP()
		method := c.Request.Method
		statusCode := c.Writer.Status()
		bodySize := c.Writer.Size()

		if raw != "" {
			path = path + "?" + raw
		}

		m.logger.WithFields(logrus.Fields{
			"status_code": statusCode,
			"latency":     latency,
			"client_ip":   clientIP,
			"method":      method,
			"path":        path,
			"body_size":   bodySize,
		}).Info("HTTP Request")
	}
}

// CORSMiddleware provides CORS middleware
func (m *Middleware) CORSMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Allow-Credentials", "true")
		c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}

// RecoveryMiddleware provides panic recovery middleware
func (m *Middleware) RecoveryMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		defer func() {
			if err := recover(); err != nil {
				m.logger.Error("Panic recovered:", err)
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
				c.Abort()
			}
		}()

		c.Next()
	}
}

// RateLimitMiddleware provides rate limiting middleware
func (m *Middleware) RateLimitMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Get client IP
		clientIP := c.ClientIP()

		// Use existing middleware library for rate limiting
		middlewareManager := middleware.NewMiddlewareManager(
			middleware.DefaultManagerConfig(),
			m.logger,
		)

		// Check rate limit
		allowed, err := middlewareManager.CheckRateLimit(c.Request.Context(), clientIP)
		if err != nil {
			m.logger.Error("Rate limit check failed:", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Rate limit check failed"})
			c.Abort()
			return
		}

		if !allowed {
			c.JSON(http.StatusTooManyRequests, gin.H{"error": "Rate limit exceeded"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// SecurityMiddleware provides security headers middleware
func (m *Middleware) SecurityMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Set security headers
		c.Header("X-Content-Type-Options", "nosniff")
		c.Header("X-Frame-Options", "DENY")
		c.Header("X-XSS-Protection", "1; mode=block")
		c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		c.Header("Content-Security-Policy", "default-src 'self'")

		c.Next()
	}
}

// RequestIDMiddleware provides request ID middleware
func (m *Middleware) RequestIDMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Generate or get request ID
		requestID := c.GetHeader("X-Request-ID")
		if requestID == "" {
			requestID = generateRequestID()
		}

		// Set request ID in header
		c.Header("X-Request-ID", requestID)

		// Set request ID in context
		c.Set("request_id", requestID)

		c.Next()
	}
}

// TimeoutMiddleware provides request timeout middleware
func (m *Middleware) TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Create context with timeout
		ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
		defer cancel()

		// Replace request context
		c.Request = c.Request.WithContext(ctx)

		// Create response writer with timeout
		timeoutWriter := &timeoutResponseWriter{
			ResponseWriter: c.Writer,
			timeout:        timeout,
		}
		c.Writer = timeoutWriter

		c.Next()
	}
}

// generateRequestID generates a unique request ID
func generateRequestID() string {
	return time.Now().Format("20060102150405") + "-" + randomString(8)
}

// randomString generates a random string of specified length
func randomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
	}
	return string(b)
}

// timeoutResponseWriter wraps gin.ResponseWriter with timeout functionality
type timeoutResponseWriter struct {
	gin.ResponseWriter
	timeout time.Duration
}

// Write implements io.Writer interface
func (w *timeoutResponseWriter) Write(data []byte) (int, error) {
	// Check if context is cancelled
	select {
	case <-w.Request().Context().Done():
		return 0, context.DeadlineExceeded
	default:
		return w.ResponseWriter.Write(data)
	}
}

// Request returns the request object
func (w *timeoutResponseWriter) Request() *http.Request {
	return w.ResponseWriter.Request()
}
